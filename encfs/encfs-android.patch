--- ./encfs-1.7.4/encfs/DirNode.cpp	2010-08-30 07:27:49.000000000 +0100
+++ ./encfs-1.7.4/encfs/DirNode.cpp	2012-01-17 00:43:29.000000000 +0000
@@ -27,7 +27,7 @@
 #include <cstdlib>
 #include <pthread.h>
 #include <unistd.h>
-#ifdef linux
+#if defined (linux) || defined (ANDROID)
 #include <sys/fsuid.h>
 #endif
 
@@ -580,20 +580,23 @@
     rLog( Info, "mkdir on %s", cyName.c_str() );
 
     // if uid or gid are set, then that should be the directory owner
+#ifndef ANDROID
     int olduid = -1;
     int oldgid = -1;
     if(uid != 0)
 	olduid = setfsuid( uid );
     if(gid != 0)
 	oldgid = setfsgid( gid );
-
+#endif
     int res = ::mkdir( cyName.c_str(), mode );
 
+#ifndef ANDROID
     if(olduid >= 0)
 	setfsuid( olduid );
     if(oldgid >= 0)
 	setfsgid( oldgid );
-
+#endif
+    
     if(res == -1)
     {
 	int eno = errno;
--- ./encfs-1.7.4/encfs/FSConfig.h	2010-08-30 07:27:49.000000000 +0100
+++ ./encfs-1.7.4/encfs/FSConfig.h	2012-01-17 00:43:29.000000000 +0000
@@ -103,7 +103,9 @@
     unsigned char *getKeyData() const;
     unsigned char *getSaltData() const;
 
+#ifndef ANDROID
 private:
+#endif    
     CipherKey makeKey(const char *password, int passwdLen);
 };
    
--- ./encfs-1.7.4/encfs/FileNode.cpp	2010-09-06 04:52:12.000000000 +0100
+++ ./encfs-1.7.4/encfs/FileNode.cpp	2012-01-17 00:43:29.000000000 +0000
@@ -169,6 +169,7 @@
     int res;
     int olduid = -1;
     int oldgid = -1;
+#ifndef ANDROID
     if(uid != 0)
     {
 	olduid = setfsuid( uid );
@@ -187,7 +188,8 @@
             return -EPERM;
         }
     }
-
+#endif
+    
     /*
      * cf. xmp_mknod() in fusexmp.c
      * The regular file stuff could be stripped off if there
@@ -202,11 +204,13 @@
     else
         res = ::mknod( _cname.c_str(), mode, rdev );
 
+#ifndef ANDROID
     if(olduid >= 0)
 	setfsuid( olduid );
     if(oldgid >= 0)
 	setfsgid( oldgid );
-
+#endif
+    
     if(res == -1)
     {
 	int eno = errno;
@@ -283,7 +287,7 @@
     if(fh >= 0)
     {
 	int res = -EIO;
-#ifdef linux
+#if defined(linux) && !defined (ANDROID)
 	if(datasync)
 	    res = fdatasync( fh );
 	else
--- ./encfs-1.7.4/encfs/FileUtils.cpp	2010-11-04 03:28:54.000000000 +0000
+++ ./encfs-1.7.4/encfs/FileUtils.cpp	2012-02-20 19:14:27.000000000 +0000
@@ -1045,6 +1045,38 @@
 	chainedIV = true;
 	externalIV = true;
         desiredKDFDuration = ParanoiaKDFDuration;
+#ifdef ANDROID    
+    } else if(configMode == Config_Compatible)
+    {
+	// xgroup(setup)
+	cout << _("Compatible configuration selected.") << "\n";
+	// AES w/ 256 bit key, stream name encoding, no initialization
+        // vectors.
+	keySize = 256;
+	blockSize = DefaultBlockSize;
+	alg = findCipherAlgorithm("AES", keySize);
+	blockMACBytes = 0;
+	blockMACRandBytes = 0;
+	externalIV = false;
+	nameIOIface = StreamNameIO::CurrentInterface();
+        uniqueIV = false;
+        chainedIV = false;
+    } else if(configMode == Config_Quick)
+    {
+	// xgroup(setup)
+	cout << _("Quick configuration selected.") << "\n";
+	// Blowfish w/ 128 bit key, stream name encoding, no
+        // initialization vectors
+	keySize = 128;
+	blockSize = DefaultBlockSize;
+	alg = findCipherAlgorithm("Blowfish", keySize);
+	blockMACBytes = 0;
+	blockMACRandBytes = 0;
+	externalIV = false;
+	nameIOIface = StreamNameIO::CurrentInterface();
+        uniqueIV = false;
+        chainedIV = false;
+#endif
     } else if(configMode == Config_Standard || answer[0] != 'x')
     {
 	// xgroup(setup)
@@ -1068,7 +1100,7 @@
 	    chainedIV = true;
 	}
     }
-
+    
     if(answer[0] == 'x' || alg.name.empty())
     {
 	if(answer[0] != 'x')
@@ -1178,6 +1210,11 @@
     // get user key and use it to encode volume key
     CipherKey userKey;
     rDebug( "useStdin: %i", useStdin );
+#ifdef ANDROID
+    if (!opts->password.empty())
+        userKey = config->makeKey( opts->password.c_str(), opts->password.length() );
+    else
+#endif        
     if(useStdin)
         userKey = config->getUserKey( useStdin );
     else if(!passwordProgram.empty())
@@ -1615,6 +1652,11 @@
 	// get user key
 	CipherKey userKey;
 
+#ifdef ANDROID
+        if(!opts->password.empty())
+            userKey = config->makeKey( opts->password.c_str(), opts->password.length() );
+        else
+#endif
         if(opts->passwordProgram.empty())
         {
             rDebug( "useStdin: %i", opts->useStdin );
--- ./encfs-1.7.4/encfs/FileUtils.h	2010-09-05 21:47:01.000000000 +0100
+++ ./encfs-1.7.4/encfs/FileUtils.h	2012-02-20 19:07:03.000000000 +0000
@@ -58,6 +58,11 @@
     Config_Prompt,
     Config_Standard,
     Config_Paranoia
+#ifdef ANDROID    
+    ,
+    Config_Compatible,
+    Config_Quick
+#endif
 };
 
 struct EncFS_Opts
@@ -72,7 +77,10 @@
 
     std::string passwordProgram; // path to password program (or empty)
     bool useStdin; // read password from stdin rather then prompting
-
+#ifdef ANDROID
+    std::string password; // supply password directly if encfs is used as a library
+#endif
+    
     bool ownerCreate; // set owner of new files to caller
 
     bool reverseEncryption; // Reverse encryption
--- ./encfs-1.7.4/encfs/RawFileIO.cpp	2009-11-29 22:04:12.000000000 +0000
+++ ./encfs-1.7.4/encfs/RawFileIO.cpp	2012-01-17 00:43:29.000000000 +0000
@@ -293,7 +293,7 @@
     if(fd >= 0 && canWrite)
     {
 	res = ::ftruncate( fd, size );
-#ifndef __FreeBSD__
+#if !defined (__FreeBSD__) && !defined (ANDROID)
 	::fdatasync( fd );
 #endif
     } else
--- ./encfs-1.7.4/encfs/encfs.cpp	2010-11-18 02:50:51.000000000 +0000
+++ ./encfs-1.7.4/encfs/encfs.cpp	2012-01-17 00:43:29.000000000 +0000
@@ -421,6 +421,7 @@
 
 	// use setfsuid / setfsgid so that the new link will be owned by the
 	// uid/gid provided by the fuse_context.
+#ifndef ANDROID
 	int olduid = -1;
 	int oldgid = -1;
 	if(ctx->publicFilesystem)
@@ -429,12 +430,15 @@
 	    olduid = setfsuid( context->uid );
 	    oldgid = setfsgid( context->gid );
 	}
+#endif
 	res = ::symlink( fromCName.c_str(), toCName.c_str() );
+#ifndef ANDROID
 	if(olduid >= 0)
 	    setfsuid( olduid );
 	if(oldgid >= 0)
 	    setfsgid( oldgid );
-
+#endif
+        
 	if(res == -1)
 	    res = -errno;
 	else
@@ -544,7 +548,11 @@
     tv[1].tv_sec = ts[1].tv_sec;
     tv[1].tv_usec = ts[1].tv_nsec / 1000;
 
+#ifndef ANDROID
     int res = lutimes( cyName.c_str(), tv);
+#else
+    int res = utimes( cyName.c_str(), tv);
+#endif    
     return (res == -1) ? -errno : ESUCCESS;
 }
 
@@ -675,7 +683,9 @@
 {
     EncFS_Context *ctx = context();
 
+    
     int res = -EIO;
+#ifndef ANDROID //TODO: find equivalent for Android
     try
     {
 	(void)path; // path should always be '/' for now..
@@ -696,6 +706,7 @@
 	rError("error caught in statfs");
 	err.log( _RLWarningChannel );
     }
+#endif
     return res;
 }
 
--- ./encfs-1.7.4/encfs/encfsctl.cpp	2010-08-30 07:27:49.000000000 +0100
+++ ./encfs-1.7.4/encfs/encfsctl.cpp	2012-01-17 00:43:29.000000000 +0000
@@ -384,7 +384,11 @@
 		fnode->getAttr( &stbuf );
 
 		struct tm stm;
+#ifdef ANDROID
+		localtime_r( (const time_t*)&stbuf.st_mtime, &stm );
+#else
 		localtime_r( &stbuf.st_mtime, &stm );
+#endif
 		stm.tm_year += 1900;
 		// TODO: when I add "%s" to the end and name.c_str(), I get a
 		// seg fault from within strlen.  Why ???
@@ -686,10 +690,12 @@
 
     int filesFound = showcruft( rootInfo, "/" );
 
+#ifndef ANDROID
     cerr << autosprintf(
 	    ngettext("Found %i invalid file.", "Found %i invalid files.", 
 		filesFound), filesFound) << "\n";
-
+#endif
+    
     return EXIT_SUCCESS;
 }
 
